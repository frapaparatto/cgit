# Refactoring Log — 2026-02-14

## Switched `compute_sha1` from CommonCrypto to OpenSSL

The original `src/core/hash.c` used Apple's CommonCrypto (`CC_SHA1`), which
works but locks the project to macOS. Replaced it with OpenSSL's `SHA1()` from
`<openssl/sha.h>` so the code compiles on any platform where OpenSSL is
available.

### What changed

- **Header swap** — `CommonCrypto/CommonCrypto.h` and
  `CommonCrypto/CommonDigest.h` replaced by `openssl/sha.h`.
- **Digest call** — `CC_SHA1(data, len, hash)` replaced by
  `SHA1(data, len, hash)`. The API is nearly identical: both take the same
  arguments and write 20 bytes into the output buffer. The difference is that
  `SHA1()` returns a pointer (NULL on failure), so we check the return value
  for robustness.
- **Digest length constant** — `CC_SHA1_DIGEST_LENGTH` replaced by
  `SHA_DIGEST_LENGTH` (both are 20).

### Why `SHA1()` and not the EVP API

OpenSSL 3.x deprecates `SHA1()` in favor of the EVP interface
(`EVP_DigestInit_ex` / `EVP_DigestUpdate` / `EVP_DigestFinal_ex`). EVP is
more flexible (algorithm-agnostic, supports streaming) but turns a 3-line
function into ~15 lines of context allocation, init, update, finalize, and
cleanup.

For a single-shot hash on an in-memory buffer, `SHA1()` does the job in one
call. The deprecation is soft — the function still works and is not going away
anytime soon. If OpenSSL ever removes it, migrating to EVP is straightforward.

### CMake changes

- Added Homebrew OpenSSL detection on macOS (`brew --prefix openssl` →
  `OPENSSL_ROOT_DIR`) so `find_package(OpenSSL)` works out of the box.
- Enabled `CMAKE_EXPORT_COMPILE_COMMANDS` so clangd picks up the correct
  include paths from `compile_commands.json`.

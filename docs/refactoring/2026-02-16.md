# Refactoring Log — 2026-02-16

## Extracted `parse_object_header` from `read_object`

The `read_object` function in `src/core/object.c` was doing two things:
reading/decompressing a git object from disk and parsing its header
(`type SP size NUL`). Separated the header parsing into a standalone utility
function for better separation of concerns.

### What changed

- **New function `parse_object_header`** (`src/core/utils.c`) — Pure parsing
  logic extracted from `read_object`. Takes a raw buffer and its length,
  returns the parsed type string, content size, and payload offset through
  output pointers. No allocations, no I/O — just parsing with validation.
- **Simplified `read_object`** (`src/core/object.c`) — Now delegates header
  parsing to `parse_object_header` and only handles orchestration: file I/O,
  decompression, size-mismatch validation, and populating the `git_object_t`
  struct. Uses `strdup` for the type instead of manual malloc + memcpy.
- **Prototype in `core.h`** — Added the declaration with corrected signature:
  `const unsigned char *buf` (matches `buffer_t.data`), `buf_len` for safe
  bounds checking, and pointer parameters (`size_t *`) for the output values.
- **New constant `CGIT_MAX_TYPE_LEN`** (`common.h`) — Replaces the magic
  number `32` used for the type buffer size. Set to 16, which covers all
  standard git object types (blob, tree, commit, tag).

### Why this split

`parse_object_header` is a pure utility that can be reused by `write_object`
or any future code that needs to inspect object headers without reading them
from disk. Keeping it allocation-free makes it easy to test and compose.

## Added idempotency check to `write_object`

`write_object` was unconditionally writing the compressed object to disk, even
if the same object already existed. Since the hash determines the path, the
content is identical by definition — but the redundant mkdir, compress, and
fwrite are wasted I/O.

### What changed

- **New `stat` guard** (`src/core/object.c`) — After building the object path,
  a `stat()` call checks whether the file already exists. If it does, the
  function skips directory creation, compression, and writing, and jumps
  straight to cleanup. The hash is still computed and returned via `hash_out`
  regardless.

### Why

This matches real git's behavior: object writes are idempotent and skip the
disk write when the object is already stored. Avoids unnecessary I/O and
prevents potential issues under concurrent writes.

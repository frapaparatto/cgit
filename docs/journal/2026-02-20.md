# 2026-02-20

## What I did

- Reviewed and fixed `serialize_tree` in `src/core/object.c`.
- Improved error messages in `serialize_tree`.
- Completed the `write-tree` command.
- Wrote a note about the `write-tree` command.

## Bugs fixed in `serialize_tree`

### 1. NULL pointer dereference (crash on entry)

`buf` was declared as `buffer_t *buf = NULL` but immediately dereferenced:

```c
buf->data = malloc(CGIT_READ_BUFFER_SIZE);  // segfault — buf is NULL
```

The pointer was never allocated. Every `buf->` access was undefined behavior.

**Fix:** dropped `buf` entirely and wrote directly to the `out` parameter, which is already a valid pointer passed by the caller.

### 2. Output never returned to the caller

At the end of the loop there was:

```c
out = buf;
```

This only reassigns the local copy of the `out` pointer — it has no effect on the caller's variable. The caller would always see an unchanged (zeroed) `buffer_t`.

**Fix:** by writing to `out->data`, `out->size`, `out->capacity` directly throughout the function, the caller's buffer is populated in place. No assignment needed.

### 3. `out->size` never initialized

`buf->size` (now `out->size`) was used in arithmetic inside the loop but never set to `0` before the loop started, so the capacity check and memcpy offset were based on garbage.

**Fix:** added `out->size = 0` immediately after the initial `malloc`.

### 4. `out->capacity` not updated after `realloc`

After doubling the buffer with `realloc`, the code updated `buf->data` but not `buf->capacity`, so the next iteration's capacity check would compare against the stale (smaller) value.

**Fix:** added `out->capacity = new_cap` after the successful `realloc`.

### 5. Overflow check was placed after `memcpy`

The `SIZE_MAX` overflow guard on `out->size + total_len` came *after* `memcpy`, meaning the data had already been written before the check could fire. Moving it before the grow block makes it a proper guard.

### 6. Silent `goto cleanup` on allocation failures

Both the initial `malloc` and the `realloc` jumped to cleanup without setting `result` or printing a message, so the function returned `CGIT_OK` on memory failure. Fixed by setting `result = CGIT_ERROR_MEMORY` and printing a specific message in each branch.

## Cleanup refactor: include paths and resource management

### Include paths

All source files that used bare `"common.h"` or `"core.h"` were relying on a compiler `-I` flag to resolve them. Fixed every include to use an explicit relative path:

- `src/core/object.c`: `"common.h"` → `"../include/common.h"`
- `src/core/hash.c`: `"common.h"` → `"../include/common.h"`
- `src/commands/ls_tree.c`: `"common.h"` and `"core.h"` → `"../include/common.h"` and `"../include/core.h"`

### `write_tree_recursive`: eliminating repeated `buffer_free` before `goto`

The blob and tree branches each declared their own block-scoped `buffer_t` (named `buf` and `out`), which made it impossible for the `cleanup` label to free them. Every error path had to call `buffer_free` manually before jumping, leading to repetition and easy-to-miss leaks:

```c
// old — repeated in every error branch
if (result != CGIT_OK) {
    buffer_free(&out);   // must remember this every time
    goto cleanup;
}
```

**Fix:** hoist `buf`, `sub_entries`, and `sub_count` to function scope. The `cleanup` label now owns all frees unconditionally. On the success path, `buffer_free(&buf)` is called once at the bottom of the loop body (safe because `buffer_free` zeroes the struct, making it idempotent), and `free_tree_entries(sub_entries, ...)` is called at the end of the tree branch to reset state for the next iteration.

```c
// new — cleanup label is the single point of truth
cleanup:
  buffer_free(&buf);
  free_tree_entries(sub_entries, sub_count);
  free_tree_entries(entries, count);
  if (dir) closedir(dir);
  return result;
```

This also fixed a memory leak: `sub_entries` was never freed on the success path of the tree branch in the original code.

### `handle_write_tree`: missing `buffer_free` in cleanup

`out` was populated by `serialize_tree` but `buffer_free(&out)` was absent from the cleanup label — a straightforward leak on every code path.

## Bug: missing `printf` in `handle_write_tree`

`write-tree` was producing an empty hash — the test got `''` instead of a 40-char string.

The hash was being computed correctly and the object was written to disk, but `handle_write_tree` never printed the result. `hash_out` was populated by `write_object` and then silently discarded.

**Fix:** add `printf("%s\n", hash_out)` before `result = 0` in `handle_write_tree`.

The reason this went unnoticed: the function was written focusing on error handling and resource cleanup. The success path — printing the output — was simply never added.


# 2026-02-20

## What I did

- Reviewed and fixed `serialize_tree` in `src/core/object.c`.
- Improved error messages in `serialize_tree`.

## Bugs fixed in `serialize_tree`

### 1. NULL pointer dereference (crash on entry)

`buf` was declared as `buffer_t *buf = NULL` but immediately dereferenced:

```c
buf->data = malloc(CGIT_READ_BUFFER_SIZE);  // segfault — buf is NULL
```

The pointer was never allocated. Every `buf->` access was undefined behavior.

**Fix:** dropped `buf` entirely and wrote directly to the `out` parameter, which is already a valid pointer passed by the caller.

### 2. Output never returned to the caller

At the end of the loop there was:

```c
out = buf;
```

This only reassigns the local copy of the `out` pointer — it has no effect on the caller's variable. The caller would always see an unchanged (zeroed) `buffer_t`.

**Fix:** by writing to `out->data`, `out->size`, `out->capacity` directly throughout the function, the caller's buffer is populated in place. No assignment needed.

### 3. `out->size` never initialized

`buf->size` (now `out->size`) was used in arithmetic inside the loop but never set to `0` before the loop started, so the capacity check and memcpy offset were based on garbage.

**Fix:** added `out->size = 0` immediately after the initial `malloc`.

### 4. `out->capacity` not updated after `realloc`

After doubling the buffer with `realloc`, the code updated `buf->data` but not `buf->capacity`, so the next iteration's capacity check would compare against the stale (smaller) value.

**Fix:** added `out->capacity = new_cap` after the successful `realloc`.

### 5. Overflow check was placed after `memcpy`

The `SIZE_MAX` overflow guard on `out->size + total_len` came *after* `memcpy`, meaning the data had already been written before the check could fire. Moving it before the grow block makes it a proper guard.

### 6. Silent `goto cleanup` on allocation failures

Both the initial `malloc` and the `realloc` jumped to cleanup without setting `result` or printing a message, so the function returned `CGIT_OK` on memory failure. Fixed by setting `result = CGIT_ERROR_MEMORY` and printing a specific message in each branch.

## What I learned

- **Pointer parameters are pass-by-value.** Assigning `out = something` inside a function does not affect the caller. To write to the caller's buffer, dereference: `out->field = ...`. This is the standard C output-parameter pattern.
- **Always initialize fields you compute from.** `size`, `capacity`, `count` — any accumulator used in arithmetic must be explicitly zeroed before use, even if the struct was zero-initialized at the call site. Don't rely on the caller.
- **Guard before you act.** Overflow checks and boundary conditions belong *before* the operation they protect, not after.

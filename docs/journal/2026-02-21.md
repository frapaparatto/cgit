# 2026-02-21

## What I did

- Fixed `buffer_append_fmt` in `src/core/object.c`.
- Completed `build_commit_content` using `buffer_append_fmt`.
- Fixed and rewrote `handle_commit_tree` in `src/commands/commit_tree.c`.
- Added `commit-tree` test cases to `tests.sh`.

## Fixing `buffer_append_fmt`

### The bug: re-initialization on every call

The original function opened with an unconditional `malloc` and reset of the buffer:

```c
buf->data = malloc(CGIT_READ_BUFFER_SIZE);
// ...
buf->capacity = CGIT_READ_BUFFER_SIZE;
buf->size = 0;  // ← always reset
```

This made it impossible to use for building content incrementally. Every call leaked the previous allocation and discarded all previously written data. `build_commit_content` called it multiple times to write individual lines — so the commit object would only ever contain the last line written.

There was also a dead `char tmp[CGIT_READ_BUFFER_SIZE]` declared at the top that was never used.

### The fix: initialize only when unset

The buffer should be set up exactly once, on the first call, and left alone on subsequent calls:

```c
if (!buf->data) {
    buf->data = malloc(CGIT_READ_BUFFER_SIZE);
    if (!buf->data) { ... return CGIT_ERROR_MEMORY; }
    buf->capacity = CGIT_READ_BUFFER_SIZE;
    buf->size = 0;
}
```

From that point on, the function only checks whether the remaining capacity is enough for the new string, grows the buffer with `realloc` if needed, and writes at `buf->data + buf->size`, incrementing `buf->size` by the formatted length.

### Design decisions

**Why `vsnprintf(NULL, 0, fmt, args)` first?** It measures the exact number of bytes the formatted string will occupy without writing anything. This avoids a fixed intermediate buffer (which could silently truncate) and avoids over-allocating. The cost is calling `vsnprintf` twice, which is acceptable since this is not a hot path.

**Why not return early on realloc failure?** A `goto cleanup` is used inside `buffer_append_fmt` even though there is no resource to free there — the caller owns the buffer and is responsible for calling `buffer_free` on error. The goto just ensures a consistent single return point.

**Why is the function `static`?** It is only used inside `object.c` — by `build_commit_content`. There is no reason to expose it through `core.h`. Keeping it static prevents it from polluting the link namespace and documents that it is an internal helper.

## Completing `build_commit_content`

With a working `buffer_append_fmt`, building the commit body became straightforward — one call per line of the git commit format:

```c
buffer_append_fmt(output, "tree %s\n", tree_hash);
if (parent_hash)
    buffer_append_fmt(output, "parent %s\n", parent_hash);
buffer_append_fmt(output, "author %s <%s> %ld %c%02d%02d\n", ...);
buffer_append_fmt(output, "committer %s <%s> %ld %c%02d%02d\n", ...);
buffer_append_fmt(output, "\n%s\n", message);
```

The timezone offset is computed from `localtime_r` → `tm_gmtoff` (seconds east of UTC), then formatted as `+HHMM` / `-HHMM`.

The blank line before the message (`"\n%s\n"`) is the header/body separator — git requires it.

## Fixes in `handle_commit_tree`

Three bugs were present and one design limitation was removed:

1. **`argc < 5`**: the command needs six tokens (`commit-tree tree -p parent -m msg`), so the guard should be `argc < 6`. With the old check, calling with fewer args would have accessed `argv[5]` out of bounds.

2. **Second flag checked `-p` instead of `-m`**: the condition at `argv[4]` was a copy-paste of the `-p` check and never validated the `-m` flag.

3. **Usage string said `write-tree`**: copy-paste from the `write-tree` handler.

4. **`-p` was required**: the original design forced a parent hash, making it impossible to create a root commit. The argument parsing was rewritten as a `while` loop over remaining argv, handling `-p` and `-m` in any order and treating `-p` as optional. `build_commit_content` already accepts `NULL` for `parent_hash`.

# 2026-02-19

## What I did

- Reviewed C patterns: the declare-NULL cleanup idiom and the `goto cleanup` error handling strategy.
- Implemented `hex_to_bytes_hash` in `src/core/hash.c` — a function that converts a 40-character hex string (e.g. `"a1b2c3..."`) into 20 raw bytes, which is the inverse of what `compute_sha1` already does.

## Bug I ran into

I initially wrote `hex_to_bytes_hash` using `sprintf`, thinking it could parse hex text into bytes. It can't — `sprintf` only *writes* formatted text, it never reads. The correct tool is `sscanf`, which *reads* from a string and parses it according to a format.

The wrong version:
```c
sprintf(&hash_out[j], "%02x", hex_hash[j * 2]);  // re-encodes one ASCII char back to hex, completely wrong
```

The fixed version:
```c
unsigned int byte;
sscanf((const char *)&hex_hash[j * 2], "%02x", &byte);  // parses two hex chars into a byte value
hash_out[j] = (unsigned char)byte;
```

## Reminder

Study `sprintf`, `sscanf` and the broader `printf`/`scanf` family better. I was confused about the direction of data flow (formatting vs parsing) and about how format specifiers like `%02x` behave in each context.

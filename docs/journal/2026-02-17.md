# Journal — 2026-02-17

## Removed `opt_e` flag from `read_object`

My `read_object` function had an `opt_e` parameter that short-circuited the
function after `build_object_path` — if the file existed, it returned success
without actually reading or decompressing anything. This was a cat-file concern
leaking into a core function: `read_object` should always read the object, and
existence checks belong elsewhere.

### What I changed

- **Removed the `opt_e` parameter** from `read_object` signature in both
  `src/core/object.c` and `src/include/core.h`. The function now always reads,
  decompresses, and parses the object.
- **New `object_exists` function** (`src/core/object.c`) — A dedicated function
  that validates the hash, builds the path, and checks `access(path, F_OK)`.
  This is what `-e` semantically needs: "does this object exist on disk?"
- **Updated `handle_cat_file`** (`src/commands/cat_file.c`) — The `-e` case now
  calls `object_exists` directly and jumps to cleanup, skipping the full
  `read_object` path entirely. I also removed the `case 'e'` from
  `cmd_cat_file` since it's handled before the object is read.

### Why

The `opt_e` flag violated separation of concerns — it made a core I/O function
aware of a specific command-line option. With `object_exists` as a standalone
function, the core layer provides a clean primitive ("does this object exist?")
and the command layer decides when to use it.

## Studied and implemented `ls-tree`

I studied how git's `ls-tree` command works by reading the tree object binary
format. The key insight is that tree entries are packed as
`<mode> <name>\0<20-byte-sha>` with no delimiters between entries — I need to
walk the buffer left-to-right, parsing each field by its terminator (space for
mode, null byte for name, fixed 20 bytes for hash).

I documented my study in `docs/learning/git-internals/ls-tree-command.md`
before writing any code.

### Architecture decisions

- **Reuse `read_object`** — The first half of `ls-tree` is identical to
  `cat-file`: validate hash, read from disk, decompress, parse header. I reuse
  the same `read_object` core function, then check that the type is `"tree"`
  before proceeding.
- **`parse_tree` in core, not in the handler** — I decided to put the tree
  parsing logic in `src/core/object.c` rather than `src/commands/ls_tree.c`.
  Multiple future commands (checkout, diff, merge) will need to parse tree
  entries, so it belongs in the core layer.
- **Type derivation inside `parse_tree`** — The binary format doesn't store the
  type string ("blob", "tree") — it's derived from the mode. I initially put a
  `set_obj_type` function in `ls_tree.c`, but then realized this is core logic:
  `parse_tree` should return fully populated entries with `type` already set.
  I implemented `type_from_mode` as a static helper in `object.c`.
- **Ownership model** — `parse_tree` allocates the entries array internally
  (only it knows the count). On success, ownership transfers to the caller. On
  failure, it frees its own partial allocations and the caller receives nothing.

### Implementation of `parse_tree`

I wrote the initial version with the right conceptual approach but several bugs:

1. **Shadowed loop variable** — The hash-reading `for` loop redeclared `i`,
   reading from `data[0..19]` every time instead of the current position. Fixed
   by using a separate `j` variable and reading from `data[i + j]`.
2. **Bogus `malloc` for `strtol` endptr** — I was allocating memory for the
   `endptr` parameter, but `strtol` writes a pointer into the parsed string, it
   doesn't need an allocation. Fixed with a plain stack `char *endptr`.
3. **`set_obj_type` local pointer assignment** — Assigning `type = "blob"`
   inside the function modified the local copy, not the caller's pointer.
   Replaced with `type_from_mode` that returns a `const char *`.
4. **Missing realloc loop** — I allocated `tmp_entries` once but never grew it.
   Fixed with `realloc` to `count + 1` on each iteration.

### Implementation of `handle_ls_tree`

The handler follows the same pattern as `handle_cat_file`:

1. Parse arguments (detect `--name-only` flag)
2. Call `read_object` to get the raw tree data
3. Verify the object type is `"tree"`
4. Call `parse_tree` to get an array of `tree_entry_t`
5. Print entries (full format or names only)
6. Cleanup: `free_object` + `free_tree_entries`

## Renamed `docs/refactoring/` to `docs/journal/`

The directory was originally created for refactoring notes, but as the project
evolves I'm logging implementation work too, not just refactoring. "Journal" is
a more accurate name. I also updated all existing entries to first person.
